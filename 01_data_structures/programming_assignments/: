'use strict';

const DIRECTIONS = [
  {label: 'WEST',  value: [-1, 0]},
  {label: 'EAST',  value: [1, 0]},
  {label: 'NORTH', value: [0, 1]},
  {label: 'SOUTH', value: [0, -1]}
];

class UF{
  constructor(N){
    this.N = N;
    this.a = new Array(N).fill(0).map((v, i) => i);
  }
  connected(p, q){
    return this.find(p).join('')  == this.find(q).join('');
  }
  find(p){
    while (p != this.a[p]){
      p = this.a[p];
    }
    return p;
  }
  union(p, q){
    if (connected(p, q)) { return; }
    let pID = this.find(p);
    let qID = this.find(q);
    this.a.forEach((v, i) => {
      if (v == pID){
        this.grid[i] = qID;
      }
    });
  }
};

class Percolation{
  constructor(N){
    this.N = N || 0;
    this.grid = new Array(N)
                    .fill(0)
                    .map((v, i) => new Array(N)
                    .fill(0)
                    .map((v, j) => ({blocked: true, root: [i, j]})));
  }
  randomIndex(){
    let rand1 = Math.floor(Math.random()*this.N);
    let rand2 = Math.floor(Math.random()*this.N);
    return [rand1, rand2];
  }
  find(p, pIDX, pIDY){
    let x = pIDX, y = pIDY, root = p.root;
    while (root[0] != x && root[1] != y){
      root = this.grid[x, y].root;
      x = root[0];
      y = root[1];
    }
    return root;
  }
  union(p, q){
    let pIDX = p[0], pIDY = p[1];
    let qIDX = pIDX + q[0], qIDY = pIDY + q[1];
    if (qIDX < 0 || qIDY < 0)             { return; }
    if (qIDX >= this.N || qIDY >= this.N) { return; }
    let tileA = this.grid[pIDX][pIDY];
    let tileB = this.grid[qIDX][qIDY];
    let pRoot = this.find(tileA, pIDX, pIDY);
    let qRoot = this.find(tileB, qIDX, qIDY);
    console.log('ROOTS', pRoot, qRoot);
    if (pRoot.join('') == qRoot.join('')){ return; }
    for(let i=0; i<this.N; i++){
      for(let j=0; j<this.N; j++){
        let tile = this.grid[i][j];
        if (tile.root == qRoot){
          this.grid[i][j].root = qRoot;
        }
      }
    }
  }
  open(){
    let indices = this.randomIndex();
    let i = indices[0];
    let j = indices[1];
    this.grid[i][j].blocked = false;
    DIRECTIONS.forEach((d) => {
      this.union([i,j], d.value);
    });
  }
  isFull(i, j){
    return this.grid[i][j].blocked;
  }
  isOpen(i, j){
    return ! this.grid[i][j].blocked;
  }
  isConnected(){
    let bottomY = this.N - 1;
    this.grid[0].forEach((t, i) => {
      if (t.root[1] == bottomY){
       return true;
      } 
    });
    return false;
  }
  showConnections(){
    this.grid.forEach((g, i) => {
      g.forEach((t, j) => {
        if (i != t.root[0] || j != t.root[1]){
          console.log('REAL INDEX', [i, j]);
          console.log('ROOT INDEX', t.root);
        }
      });
    });
  }
  render(){
    this.grid.forEach((g) => {
      let sentence = g.map((line) => {
        if (line.blocked) {
          return 'B ';
        } else {
          return 'O ';
        }
      });
      console.log(sentence.join(''));
    });
  }
};

let percolator = new Percolation(5);
percolator.render();
let count = 0;
let connected = false;
while (! connected) {
  percolator.open();
  connected = percolator.isConnected();
  count++;
}
console.log('\n');
percolator.render();
console.log('COUNT', count);
